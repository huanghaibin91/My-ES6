<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>set</title>
</head>

<body>
    <script>
        // ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，
        // 用来生成 Set 数据结构
        const s = new Set();
        [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x)); // 2 3 5 4

        // Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化
        const set = new Set([1, 2, 3, 4, 4]);
        // [...set] // 1 2 3 4，数组去重
        // [...new Set(array)]

        // Set 结构的实例有以下属性。
        //     Set.prototype.constructor：构造函数，默认就是Set函数。
        //     Set.prototype.size：返回Set实例的成员总数。
        // Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。
        //     add(value)：添加某个值，返回Set结构本身。
        //     delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
        //     has(value)：返回一个布尔值，表示该值是否为Set的成员。
        //     clear()：清除所有成员，没有返回值
        // Set 结构的实例有四个遍历方法，可以用于遍历成员。
        //     keys()：返回键名的遍历器
        //     values()：返回键值的遍历器，可以省略values方法，直接用for...of循环遍历 Set
        //     entries()：返回键值对的遍历器
        //     forEach(value, key, set)：使用回调函数遍历每个成员，因为set没有键，所以value和key相同，这点跟数组不一样


        // Array.from方法可以将 Set 结构转为数组去除数组重复成员的另一种方法
        function dedupe(array) {
            return Array.from(new Set(array));
        }
        dedupe([1, 1, 2, 3]) // [1, 2, 3]

        // Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）
        let a = new Set([1, 2, 3]);
        let b = new Set([4, 3, 2]);
        // 并集
        let union = new Set([...a, ...b]);
        // Set {1, 2, 3, 4}
        // 交集
        let intersect = new Set([...a].filter(x => b.has(x)));
        // set {2, 3}
        // 差集
        let difference = new Set([...a].filter(x => !b.has(x)));
        // Set {1}

        // WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
        // 首先，WeakSet 的成员只能是对象，而不能是其他类型的值
        // WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，
        // 如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中
        // WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。
        // WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏
        const ws = new WeakSet();

        // WeakSet 结构有以下三个方法：
        //     WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
        //     WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
        //     WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。



    </script>
</body>

</html>